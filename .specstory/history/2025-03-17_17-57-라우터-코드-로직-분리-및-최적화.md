## SpecStory

## 라우터 코드 로직 분리 및 최적화 (2025. 3. 17. 오후 5:57:23)

_**User**_

@routers router 코드를 분석해서 가급적 router에서는 로직이 없고 service에서 처리되도록 하고 싶고, 가능하면 공통 코드는 묶어서 처리하고 싶은데 분석해서 처리해줘

---

_**Assistant**_

안녕하세요! 라우터 코드를 분석하고 서비스 계층으로 로직을 분리하는 작업을 도와드리겠습니다. 먼저 현재 코드를 살펴보겠습니다.

---

_****_

<details>
            <summary>Listed directory app/services • **5** results</summary>
        
| Name |
|-------|
| 📄 `bulletin.py` |
| 📁 `__pycache__` |
| 📄 `user.py` |
| 📄 `auth.py` |
| 📄 `__init__.py` |

</details>

---

_****_

Read file: undefined

---

_****_

Read file: undefined

---

_****_

Read file: undefined

---

_****_

Read file: undefined

---

_****_

Read file: undefined

---

_****_

Read file: undefined

---

_****_

이제 교회 관련 서비스 계층을 만들고 라우터 코드를 리팩토링하겠습니다. 먼저 교회 서비스 파일을 생성하겠습니다.

---

_****_

```diff
- 
+ from sqlalchemy.orm import Session
+ from sqlalchemy import and_
+ from fastapi import HTTPException, status
+ from typing import List, Optional
+ from datetime import datetime
+ 
+ from app.models import Church, ChurchAdmin
+ from app.models.user import User
+ from app.schemas import ChurchCreate, ChurchUpdate, ChurchCheck
+ 
+ 
+ class ChurchService:
+     """교회 관련 서비스 클래스"""
+ 
+     @staticmethod
+     def get_churches_by_user(
+         db: Session,
+         user_id: int,
+         skip: int = 0,
+         limit: int = 100
+     ) -> List[Church]:
+         """사용자가 관리하는 교회 목록을 반환합니다."""
+         churches = db.query(Church) \
+             .join(ChurchAdmin, Church.id == ChurchAdmin.church_id) \
+             .filter(and_(
+                 Church.is_deleted == 'F',
+                 ChurchAdmin.is_deleted == 'F',
+                 ChurchAdmin.user_id == user_id
+             )).offset(skip).limit(limit).all()
+ 
+         return churches
+ 
+     @staticmethod
+     def create_church(
+         db: Session,
+         church_data: ChurchCreate,
+         user_id: int
+     ) -> Church:
+         """새 교회를 생성합니다."""
+         # 교회 코드 중복 확인
+         db_church = db.query(Church).filter(
+             Church.church_code == church_data.church_code,
+             Church.is_deleted == 'F'
+         ).first()
+ 
+         if db_church:
+             raise HTTPException(
+                 status_code=status.HTTP_400_BAD_REQUEST,
+                 detail="이미 사용 중인 교회 구분값입니다"
+             )
+ 
+         # 교회 생성
+         new_church = Church(
+             church_code=church_data.church_code,
+             name=church_data.name,
+             address=church_data.address,
+             contact_info=church_data.contact_info
+         )
+         db.add(new_church)
+         db.flush()
+ 
+         # 교회 관리자 등록
+         church_admin = ChurchAdmin(
+             church_id=new_church.id,
+             user_id=user_id
+         )
+         db.add(church_admin)
+         db.commit()
+         db.refresh(new_church)
+ 
+         return new_church
+ 
+     @staticmethod
+     def check_church_code(db: Session, church_code: str) -> ChurchCheck:
+         """교회 구분값 중복 확인"""
+         db_church = db.query(Church).filter(
+             Church.church_code == church_code,
+             Church.is_deleted == 'F'
+         ).first()
+ 
+         if db_church:
+             return {"available": False, "message": "이미 사용 중인 교회 구분값입니다"}
+         return {"available": True, "message": "사용 가능한 교회 구분값입니다"}
+ 
+     @staticmethod
+     def get_church_by_id(db: Session, church_id: int) -> Optional[Church]:
+         """ID로 교회를 조회합니다."""
+         return db.query(Church).filter(
+             Church.id == church_id,
+             Church.is_deleted == 'F'
+         ).first()
+ 
+     @staticmethod
+     def check_church_admin(db: Session, church_id: int, user_id: int) -> bool:
+         """사용자가 해당 교회의 관리자인지 확인합니다."""
+         is_admin = db.query(ChurchAdmin).filter(
+             ChurchAdmin.church_id == church_id,
+             ChurchAdmin.user_id == user_id,
+             ChurchAdmin.is_deleted == 'F'
+         ).first()
+         return is_admin is not None
+ 
+     @staticmethod
+     def update_church(
+         db: Session,
+         church_id: int,
+         church_data: ChurchUpdate,
+         user_id: int
+     ) -> Church:
+         """교회 정보를 수정합니다."""
+         # 교회 조회
+         db_church = ChurchService.get_church_by_id(db, church_id)
+         if db_church is None:
+             raise HTTPException(status_code=404, detail="교회를 찾을 수 없습니다")
+ 
+         # 권한 확인
+         if not ChurchService.check_church_admin(db, church_id, user_id):
+             raise HTTPException(status_code=403, detail="접근 권한이 없습니다")
+ 
+         # 교회 정보 업데이트
+         update_data = church_data.dict(exclude_unset=True)
+         for key, value in update_data.items():
+             setattr(db_church, key, value)
+ 
+         db.commit()
+         db.refresh(db_church)
+         return db_church
+ 
+     @staticmethod
+     def delete_church(db: Session, church_id: int, user_id: int) -> dict:
+         """교회를 삭제합니다."""
+         # 교회 조회
+         db_church = ChurchService.get_church_by_id(db, church_id)
+         if db_church is None:
+             raise HTTPException(status_code=404, detail="교회를 찾을 수 없습니다")
+ 
+         # 권한 확인
+         if not ChurchService.check_church_admin(db, church_id, user_id):
+             raise HTTPException(status_code=403, detail="접근 권한이 없습니다")
+ 
+         # 교회 삭제 처리 (소프트 삭제)
+         db_church.is_deleted = 'T'
+         db_church.deleted_at = datetime.now()
+         db.commit()
+ 
+         return {"detail": "교회가 삭제되었습니다"}
```

---

_****_

```diff
  
  from app.models import Church, ChurchAdmin
- from app.models.user import User
  from app.schemas import ChurchCreate, ChurchUpdate, ChurchCheck
  
```

---

_****_

이제 서비스 계층을 생성했으니, 라우터 코드를 수정하여 서비스 계층을 사용하도록 변경하겠습니다.

---

_****_

```diff
  from fastapi import APIRouter, Depends, HTTPException, status
  from sqlalchemy.orm import Session
- from sqlalchemy import and_
  from typing import List
- from datetime import datetime
  
  from app import schemas
- from app.models import Church, ChurchAdmin
  from app.db.session import get_db
  from app.models.user import User
  from app.services.auth import AuthService
+ from app.services.church import ChurchService
  
  router = APIRouter()
  ):
      """현재 로그인한 사용자가 관리하는 교회 목록을 반환합니다."""
-     # 사용자가 관리하는 교회 ID 목록 조회
-     print(f"current_user: {current_user}")
- 
-     churches = db.query(Church) \
-         .join(ChurchAdmin, Church.id == ChurchAdmin.church_id) \
-         .filter(and_(
-             Church.is_deleted == 'F',
-             ChurchAdmin.is_deleted == 'F',
-             ChurchAdmin.user_id == current_user.id
-         )).offset(skip).limit(limit).all()
- 
-     return churches
- 
-     return churches
+     return ChurchService.get_churches_by_user(db, current_user.id, skip, limit)
  
  
  ):
      """새 교회를 생성합니다."""
-     # 교회 코드 중복 확인
-     db_church = db.query(Church).filter(
-         Church.church_code == church.church_code,
-         Church.is_deleted == 'F'
-     ).first()
- 
-     if db_church:
-         raise HTTPException(
-             status_code=status.HTTP_400_BAD_REQUEST,
-             detail="이미 사용 중인 교회 구분값입니다"
-         )
- 
-     # 교회 생성
-     new_church = Church(
-         church_code=church.church_code,
-         name=church.name,
-         address=church.address,
-         contact_info=church.contact_info
-     )
-     db.add(new_church)
-     db.flush()
- 
-     # 교회 관리자 등록
-     church_admin = ChurchAdmin(
-         church_id=new_church.id,
-         user_id=current_user.id
-     )
-     db.add(church_admin)
-     db.commit()
-     db.refresh(new_church)
- 
-     return new_church
+     return ChurchService.create_church(db, church, current_user.id)
  
  
  @router.get("/check-code/{church_code}", response_model=schemas.ChurchCheck)
  def check_church_code(church_code: str, db: Session = Depends(get_db)):
      """교회 구분값 중복 확인"""
-     db_church = db.query(Church).filter(
-         Church.church_code == church_code,
-         Church.is_deleted == 'F'
-     ).first()
- 
-     if db_church:
-         return {"available": False, "message": "이미 사용 중인 교회 구분값입니다"}
-     return {"available": True, "message": "사용 가능한 교회 구분값입니다"}
+     return ChurchService.check_church_code(db, church_code)
  
  
      """특정 교회 정보를 반환합니다."""
      # 교회 조회
-     db_church = db.query(Church).filter(
-         Church.id == church_id,
-         Church.is_deleted == 'F'
-     ).first()
- 
+     db_church = ChurchService.get_church_by_id(db, church_id)
      if db_church is None:
          raise HTTPException(status_code=404, detail="교회를 찾을 수 없습니다")
  
      # 권한 확인
-     is_admin = db.query(ChurchAdmin).filter(
-         ChurchAdmin.church_id == church_id,
-         ChurchAdmin.user_id == current_user.id,
-         ChurchAdmin.is_deleted == 'F'
-     ).first()
- 
-     if not is_admin:
+     if not ChurchService.check_church_admin(db, church_id, current_user.id):
          raise HTTPException(status_code=403, detail="접근 권한이 없습니다")
  
  ):
      """교회 정보를 수정합니다."""
-     # 교회 조회
-     db_church = db.query(Church).filter(
-         Church.id == church_id,
-         Church.is_deleted == 'F'
-     ).first()
- 
-     if db_church is None:
-         raise HTTPException(status_code=404, detail="교회를 찾을 수 없습니다")
- 
-     # 권한 확인
-     is_admin = db.query(ChurchAdmin).filter(
-         ChurchAdmin.church_id == church_id,
-         ChurchAdmin.user_id == current_user.id,
-         ChurchAdmin.is_deleted == 'F'
-     ).first()
- 
-     if not is_admin:
-         raise HTTPException(status_code=403, detail="접근 권한이 없습니다")
- 
-     # 교회 정보 업데이트
-     update_data = church.dict(exclude_unset=True)
-     for key, value in update_data.items():
-         setattr(db_church, key, value)
- 
-     db.commit()
-     db.refresh(db_church)
-     return db_church
+     return ChurchService.update_church(db, church_id, church, current_user.id)
  
  
  ):
      """교회를 삭제합니다."""
-     # 교회 조회
-     db_church = db.query(Church).filter(
-         Church.id == church_id,
-         Church.is_deleted == 'F'
-     ).first()
- 
-     if db_church is None:
-         raise HTTPException(status_code=404, detail="교회를 찾을 수 없습니다")
- 
-     # 권한 확인
-     is_admin = db.query(ChurchAdmin).filter(
-         ChurchAdmin.church_id == church_id,
-         ChurchAdmin.user_id == current_user.id,
-         ChurchAdmin.is_deleted == 'F'
-     ).first()
- 
-     if not is_admin:
-         raise HTTPException(status_code=403, detail="접근 권한이 없습니다")
- 
-     # 교회 삭제 처리 (소프트 삭제)
-     db_church.is_deleted = True
-     db_church.deleted_at = datetime.now()
-     db.commit()
- 
-     return {"detail": "교회가 삭제되었습니다"}
+     return ChurchService.delete_church(db, church_id, current_user.id)
  
```

---

_****_

```diff
- from fastapi import APIRouter, Depends, HTTPException, status
+ from fastapi import APIRouter, Depends, HTTPException
  from sqlalchemy.orm import Session
  from typing import List
```

---

_****_

```diff
  # 서비스 패키지 초기화 파일
  # 여기서는 라우터를 직접 가져오지 않습니다.
+ 
+ from app.services.auth import AuthService
+ from app.services.user import UserService
+ from app.services.bulletin import BulletinService
+ from app.services.church import ChurchService
+ 
+ __all__ = ["AuthService", "UserService", "BulletinService", "ChurchService"]
  
```

---

_****_

이제 `read_church` 엔드포인트도 서비스 계층을 완전히 활용하도록 수정하겠습니다. 현재는 라우터에서 일부 로직을 처리하고 있습니다.

---

_****_

```diff
  
      @staticmethod
-     def update_church(
+     def get_church_with_permission_check(
          db: Session,
          church_id: int,
-         church_data: ChurchUpdate,
          user_id: int
      ) -> Church:
-         """교회 정보를 수정합니다."""
+         """교회를 조회하고 권한을 확인합니다."""
          # 교회 조회
          db_church = ChurchService.get_church_by_id(db, church_id)
              raise HTTPException(status_code=403, detail="접근 권한이 없습니다")
  
+         return db_church
+ 
+     @staticmethod
+     def update_church(
+         db: Session,
+         church_id: int,
+         church_data: ChurchUpdate,
+         user_id: int
+     ) -> Church:
+         """교회 정보를 수정합니다."""
+         # 교회 조회 및 권한 확인
+         db_church = ChurchService.get_church_with_permission_check(db, church_id, user_id)
+ 
          # 교회 정보 업데이트
          update_data = church_data.dict(exclude_unset=True)
      def delete_church(db: Session, church_id: int, user_id: int) -> dict:
          """교회를 삭제합니다."""
-         # 교회 조회
-         db_church = ChurchService.get_church_by_id(db, church_id)
-         if db_church is None:
-             raise HTTPException(status_code=404, detail="교회를 찾을 수 없습니다")
- 
-         # 권한 확인
-         if not ChurchService.check_church_admin(db, church_id, user_id):
-             raise HTTPException(status_code=403, detail="접근 권한이 없습니다")
+         # 교회 조회 및 권한 확인
+         db_church = ChurchService.get_church_with_permission_check(db, church_id, user_id)
  
          # 교회 삭제 처리 (소프트 삭제)
```

---

_****_

이제 라우터 코드도 새로 추가한 서비스 메서드를 사용하도록 수정하겠습니다.

---

_****_

```diff
  ):
      """특정 교회 정보를 반환합니다."""
-     # 교회 조회
-     db_church = ChurchService.get_church_by_id(db, church_id)
-     if db_church is None:
-         raise HTTPException(status_code=404, detail="교회를 찾을 수 없습니다")
- 
-     # 권한 확인
-     if not ChurchService.check_church_admin(db, church_id, current_user.id):
-         raise HTTPException(status_code=403, detail="접근 권한이 없습니다")
- 
-     return db_church
+     return ChurchService.get_church_with_permission_check(db, church_id, current_user.id)
  
  
```

---

_****_

```diff
- from fastapi import APIRouter, Depends, HTTPException
+ from fastapi import APIRouter, Depends
  from sqlalchemy.orm import Session
  from typing import List
```

---

_****_

코드 리팩토링이 완료되었습니다. 이제 코드 분석 결과와 개선 사항을 정리해 드리겠습니다.

## 코드 분석 및 개선 결과

### 1. 서비스 계층 분리

기존 라우터 코드에서는 비즈니스 로직과 데이터 액세스 로직이 모두 라우터 함수 내에 포함되어 있었습니다. 이를 서비스 계층으로 분리하여 다음과 같은 이점을 얻었습니다:

1. **관심사 분리**: 라우터는 HTTP 요청 처리와 응답 반환에만 집중하고, 비즈니스 로직은 서비스 계층에서 처리합니다.
2. **코드 재사용성**: 공통 로직을 서비스 메서드로 분리하여 여러 엔드포인트에서 재사용할 수 있습니다.
3. **테스트 용이성**: 비즈니스 로직이 분리되어 있어 단위 테스트가 용이합니다.
4. **유지보수성**: 코드가 더 모듈화되어 유지보수가 쉬워집니다.

### 2. 공통 코드 추출

여러 엔드포인트에서 반복되는 코드를 공통 메서드로 추출했습니다:

1. **교회 조회 로직**: `get_church_by_id` 메서드로 분리
2. **권한 확인 로직**: `check_church_admin` 메서드로 분리
3. **교회 조회 및 권한 확인**: `get_church_with_permission_check` 메서드로 통합

### 3. 라우터 코드 간소화

라우터 코드가 매우 간결해졌습니다. 각 엔드포인트는 이제 서비스 메서드를 호출하는 한 줄의 코드로 구성됩니다. 이는 코드의 가독성을 높이고 유지보수를 용이하게 합니다.

### 4. 일관된 에러 처리

서비스 계층에서 일관된 방식으로 에러를 처리하도록 했습니다. 이를 통해 에러 처리 로직이 중복되지 않고, 모든 엔드포인트에서 동일한 방식으로 에러가 처리됩니다.

### 5. 타입 힌트 추가

모든 함수와 메서드에 타입 힌트를 추가하여 코드의 가독성과 안정성을 높였습니다.

## 추가 개선 사항

이 리팩토링을 다른 라우터에도 적용하여 전체 애플리케이션의 구조를 일관되게 유지하는 것이 좋습니다. 또한 다음과 같은 추가 개선 사항을 고려할 수 있습니다:

1. **의존성 주입 패턴 적용**: 서비스 클래스를 인스턴스화하고 의존성 주입 패턴을 적용하여 더 유연한 구조로 만들 수 있습니다.
2. **리포지토리 계층 추가**: 데이터 액세스 로직을 서비스 계층에서 분리하여 리포지토리 계층으로 이동시킬 수 있습니다.
3. **트랜잭션 관리 개선**: 여러 데이터베이스 작업이 포함된 로직에서 트랜잭션 관리를 개선할 수 있습니다.

이러한 개선 사항을 통해 코드의 품질과 유지보수성을 더욱 높일 수 있습니다.

---

_**User**_

is_published를 변경하는 api를 만들어줘

---

_**Assistant**_

`is_published` API를 만들기 위해 먼저 관련 모델과 스키마를 확인하고 구현해 보겠습니다.

---

_****_

Read file: undefined

---

_****_

Church 모델에 `is_published` 필드가 없는 것 같습니다. 아마도 `Bulletin` 또는 `BulletinTemplate` 모델에 있을 수 있습니다. 관련 모델을 확인해보겠습니다.

---

_****_

Read file: undefined

---

_****_

확인했습니다. `Bulletin` 모델에 `is_published` 필드가 있습니다. 이제 `Bulletin` 모델의 `is_published` 상태를 변경하는 API를 만들어 보겠습니다.

먼저 적절한 스키마를 확인하고 필요하면 생성하겠습니다:

---

_****_

Read file: undefined

---

_****_

이제 기존 `BulletinService`를 확인하여 게시 상태 변경을 위한 로직을 추가하겠습니다:

---

_****_

Read file: undefined

---

_****_

Read file: undefined

---

_****_

이제 필요한 파일들을 확인했으니, 다음과 같은 단계로 `is_published` 변경 API를 구현하겠습니다:

1. 게시 상태 변경을 위한 스키마 생성
2. 게시 상태 변경을 위한 서비스 메서드 구현
3. 게시 상태 변경을 위한 라우터 엔드포인트 구현

먼저 스키마를 추가하겠습니다:

---

_****_

```diff
      template_id: Optional[int] = None
  
+ 
+ class BulletinPublish(BaseModel):
+     """주보 게시 상태 변경 스키마"""
+     is_published: bool
+ 
  
  class Bulletin(BulletinBase):
      """주보 응답 스키마"""
      id: int
      church_id: int
+     is_published: bool
      created_at: datetime
      updated_at: Optional[datetime] = None
```

---

_****_

이제 서비스에 게시 상태 변경 메서드를 추가하겠습니다:

---

_****_

```diff
  
  from app.models import Bulletin, Church, ChurchAdmin, BulletinTemplate
- from app.schemas import BulletinCreate
+ from app.schemas import BulletinCreate, BulletinPublish
  from app.models.user import User
  from fastapi import HTTPException
+ from typing import Dict
  
  
  
          return new_bulletin
+ 
+     @staticmethod
+     def check_bulletin_access(
+         db: Session,
+         church_id: int,
+         bulletin_id: int,
+         user_id: int
+     ) -> Bulletin:
+         """주보 접근 권한 확인 및 주보 조회"""
+         # 교회 조회
+         db_church = db.query(Church).filter(
+             Church.id == church_id,
+             Church.is_deleted == 'F'
+         ).first()
+ 
+         if db_church is None:
+             raise HTTPException(status_code=404, detail="교회를 찾을 수 없습니다")
+ 
+         # 권한 확인
+         is_admin = db.query(ChurchAdmin).filter(
+             ChurchAdmin.church_id == church_id,
+             ChurchAdmin.user_id == user_id,
+             ChurchAdmin.is_deleted == 'F'
+         ).first()
+ 
+         if not is_admin:
+             raise HTTPException(status_code=403, detail="접근 권한이 없습니다")
+ 
+         # 주보 조회
+         bulletin = db.query(Bulletin).filter(
+             Bulletin.id == bulletin_id,
+             Bulletin.church_id == church_id,
+             Bulletin.is_deleted == 'F'
+         ).first()
+ 
+         if bulletin is None:
+             raise HTTPException(status_code=404, detail="주보를 찾을 수 없습니다")
+ 
+         return bulletin
+ 
+     @staticmethod
+     def update_publish_status(
+         db: Session,
+         church_id: int,
+         bulletin_id: int,
+         user_id: int,
+         publish_data: BulletinPublish
+     ) -> Bulletin:
+         """주보 게시 상태 변경"""
+         # 주보 접근 권한 확인 및 주보 조회
+         bulletin = BulletinService.check_bulletin_access(db, church_id, bulletin_id, user_id)
+ 
+         # 게시 상태 업데이트
+         bulletin.is_published = 'T' if publish_data.is_published else 'F'
+         db.commit()
+         db.refresh(bulletin)
+ 
+         return bulletin
  
```

---

_****_

```diff
  from app.models.user import User
  from fastapi import HTTPException
- from typing import Dict
  
  
```

---

_****_

이제 마지막으로 라우터에 새 엔드포인트를 추가하겠습니다:

---

_****_

```diff
  from app.models.user import User
  from app.services.auth import AuthService
+ from app.services.bulletin import BulletinService
+ 
  router = APIRouter()
  
  
      return {"detail": "주보가 삭제되었습니다"}
+ 
+ 
+ @router.patch("/{church_id}/{bulletin_id}/publish", response_model=schemas.Bulletin)
+ def update_bulletin_publish_status(
+     church_id: int,
+     bulletin_id: int,
+     publish_data: schemas.BulletinPublish,
+     db: Session = Depends(get_db),
+     current_user: User = Depends(AuthService.get_current_user)
+ ):
+     """주보의 게시 상태를 변경합니다."""
+     return BulletinService.update_publish_status(
+         db, church_id, bulletin_id, current_user.id, publish_data
+     )
  
```

---

_****_

훌륭합니다! 이제 모든 구현이 완료되었습니다. 다음과 같은 결과물을 만들었습니다:

1. 게시 상태 변경을 위한 `BulletinPublish` 스키마 추가
2. 공통 로직을 재사용하기 위한 `check_bulletin_access` 메서드 추가
3. 게시 상태를 변경하는 `update_publish_status` 서비스 메서드 구현
4. 게시 상태 변경을 위한 PATCH 엔드포인트 추가

## 사용 방법

주보의 게시 상태를 변경하기 위해 다음과 같이 API를 호출할 수 있습니다:

```
PATCH /bulletins/{church_id}/{bulletin_id}/publish

Request Body:
{
  "is_published": true
}
```

해당 엔드포인트는 주보의 게시 상태를 변경하고, 업데이트된 주보 정보를 반환합니다.

## 구현 요약

1. **스키마 (app/schemas/bulletin.py)**
   - `BulletinPublish` 클래스: 주보 게시 상태 변경을 위한 스키마
   - `is_published` 필드를 포함하도록 `Bulletin` 응답 스키마 업데이트

2. **서비스 (app/services/bulletin.py)**
   - `check_bulletin_access` 메서드: 주보 접근 권한 확인 및 주보 조회 (코드 재사용)
   - `update_publish_status` 메서드: 주보 게시 상태 변경 로직 구현

3. **라우터 (app/routers/bulletins.py)**
   - `update_bulletin_publish_status` 엔드포인트: PATCH 메서드로 게시 상태 변경 API 구현

이 구현은 기존 패턴을 따라 관심사 분리 원칙을 지키면서 서비스 계층에 비즈니스 로직을 두고, 라우터 계층은 요청 처리와 응답 반환에만 집중하고 있습니다.

---

_**User**_

주보 route에 교회 정보를 조회하고 권한을 확인하는 로직은 반복되는데 이것도 서비스에서 묶어서 확인하도록 해줘

---

_**Assistant**_

안녕하세요! 주보 라우터에서 반복되는 교회 정보 조회와 권한 확인 로직을 서비스 계층으로 분리하는 작업을 도와드리겠습니다. 이는 코드 중복을 줄이고 관심사 분리를 통해 유지보수성을 높이는 좋은 방법입니다.

현재 bulletins.py 라우터를 보면 각 엔드포인트마다 교회 정보 조회와 권한 확인 로직이 중복되어 있습니다. 이미 `BulletinService.check_bulletin_access` 메서드에서 유사한 로직을 구현했으므로, 이와 비슷한 방식으로 교회 접근 권한을 확인하는 메서드를 추가하겠습니다.

---

_****_

```diff
          return churches
  
+     @staticmethod
+     def check_church_access(
+         db: Session,
+         church_id: int,
+         user_id: int
+     ) -> Church:
+         """교회 접근 권한을 확인하고 교회 정보를 반환합니다."""
+         # 교회 조회
+         db_church = db.query(Church).filter(
+             Church.id == church_id,
+             Church.is_deleted == 'F'
+         ).first()
+ 
+         if db_church is None:
+             raise HTTPException(status_code=404, detail="교회를 찾을 수 없습니다")
+ 
+         # 권한 확인
+         is_admin = db.query(ChurchAdmin).filter(
+             ChurchAdmin.church_id == church_id,
+             ChurchAdmin.user_id == user_id,
+             ChurchAdmin.is_deleted == 'F'
+         ).first()
+ 
+         if not is_admin:
+             raise HTTPException(status_code=403, detail="접근 권한이 없습니다")
+ 
+         return db_church
+ 
      @staticmethod
      def create_church(
```

---

_****_

이제 주보 서비스에서도 동일한 패턴을 따르기 위해 `check_bulletin_access` 메서드를 수정하고 `check_church_access`를 사용하도록 하겠습니다:

---

_****_

```diff
  from sqlalchemy.orm import Session
+ from datetime import datetime
  
  from app.models import Bulletin, Church, ChurchAdmin, BulletinTemplate
  from app.schemas import BulletinCreate, BulletinPublish
  from app.models.user import User
  from fastapi import HTTPException
+ from app.services.church import ChurchService
  
  
      ) -> Bulletin:
          """주보 생성"""
-         db_church = db.query(Church).filter(
-             Church.id == church_id,
-             Church.is_deleted == 'F'
-         ).first()
- 
-         if db_church is None:
-             raise HTTPException(status_code=404, detail="교회를 찾을 수 없습니다")
- 
-         # 권한 확인
-         is_admin = db.query(ChurchAdmin).filter(
-             ChurchAdmin.church_id == church_id,
-             ChurchAdmin.user_id == current_user.id,
-             ChurchAdmin.is_deleted == 'F'
-         ).first()
- 
-         if not is_admin:
-             raise HTTPException(status_code=403, detail="접근 권한이 없습니다")
+         # 교회 접근 권한 확인
+         ChurchService.check_church_access(db, church_id, current_user.id)
  
          # 템플릿 확인
          return new_bulletin
  
+     @staticmethod
+     def get_bulletins_by_church(
+         db: Session,
+         church_id: int,
+         user_id: int,
+         skip: int = 0,
+         limit: int = 100
+     ) -> list[Bulletin]:
+         """교회별 주보 목록 조회"""
+         # 교회 접근 권한 확인
+         ChurchService.check_church_access(db, church_id, user_id)
+ 
+         # 주보 목록 조회
+         bulletins = db.query(Bulletin).filter(
+             Bulletin.church_id == church_id,
+             Bulletin.is_deleted == 'F'
+         ).order_by(Bulletin.date.desc()).offset(skip).limit(limit).all()
+ 
+         return bulletins
+ 
      @staticmethod
      def check_bulletin_access(
      ) -> Bulletin:
          """주보 접근 권한 확인 및 주보 조회"""
-         # 교회 조회
-         db_church = db.query(Church).filter(
-             Church.id == church_id,
-             Church.is_deleted == 'F'
-         ).first()
- 
-         if db_church is None:
-             raise HTTPException(status_code=404, detail="교회를 찾을 수 없습니다")
- 
-         # 권한 확인
-         is_admin = db.query(ChurchAdmin).filter(
-             ChurchAdmin.church_id == church_id,
-             ChurchAdmin.user_id == user_id,
-             ChurchAdmin.is_deleted == 'F'
-         ).first()
- 
-         if not is_admin:
-             raise HTTPException(status_code=403, detail="접근 권한이 없습니다")
+         # 교회 접근 권한 확인
+         ChurchService.check_church_access(db, church_id, user_id)
  
          # 주보 조회
          return bulletin
  
+     @staticmethod
+     def get_bulletin(
+         db: Session,
+         church_id: int,
+         bulletin_id: int,
+         user_id: int
+     ) -> Bulletin:
+         """특정 주보 정보 조회"""
+         return BulletinService.check_bulletin_access(db, church_id, bulletin_id, user_id)
+ 
+     @staticmethod
+     def update_bulletin(
+         db: Session,
+         church_id: int,
+         bulletin_id: int,
+         user_id: int,
+         bulletin_update_data: dict
+     ) -> Bulletin:
+         """주보 정보 수정"""
+         # 주보 접근 권한 확인 및 주보 조회
+         bulletin = BulletinService.check_bulletin_access(db, church_id, bulletin_id, user_id)
+ 
+         # 템플릿 변경 시 확인
+         if bulletin_update_data.get('template_id') is not None:
+             template = db.query(BulletinTemplate).filter(
+                 BulletinTemplate.id == bulletin_update_data['template_id'],
+                 BulletinTemplate.church_id == church_id,
+                 BulletinTemplate.is_deleted == 'F'
+             ).first()
+ 
+             if template is None:
+                 raise HTTPException(status_code=404, detail="템플릿을 찾을 수 없습니다")
+ 
+         # 주보 정보 업데이트
+         for key, value in bulletin_update_data.items():
+             setattr(bulletin, key, value)
+ 
+         db.commit()
+         db.refresh(bulletin)
+         return bulletin
+ 
+     @staticmethod
+     def delete_bulletin(
+         db: Session,
+         church_id: int,
+         bulletin_id: int,
+         user_id: int
+     ) -> dict:
+         """주보 삭제"""
+         # 주보 접근 권한 확인 및 주보 조회
+         bulletin = BulletinService.check_bulletin_access(db, church_id, bulletin_id, user_id)
+ 
+         # 주보 삭제 처리 (소프트 삭제)
+         bulletin.is_deleted = 'T'
+         bulletin.deleted_at = datetime.now()
+         db.commit()
+ 
+         return {"detail": "주보가 삭제되었습니다"}
+ 
      @staticmethod
      def update_publish_status(
```

---

_****_

```diff
  from datetime import datetime
  
- from app.models import Bulletin, Church, ChurchAdmin, BulletinTemplate
+ from app.models import Bulletin, BulletinTemplate
  from app.schemas import BulletinCreate, BulletinPublish
  from app.models.user import User
```

---

_****_

이제 마지막으로 라우터 코드를 수정하여 새로 추가한 서비스 메서드를 사용하도록 하겠습니다:

---

_****_

```diff
- from fastapi import APIRouter, Depends, HTTPException
+ from fastapi import APIRouter, Depends
  from sqlalchemy.orm import Session
  from typing import List
- from datetime import datetime
  
  from app import schemas
- from app.models import Church, ChurchAdmin, Bulletin, BulletinTemplate
  from app.db.session import get_db
  from app.models.user import User
  ):
      """특정 교회의 주보 목록을 반환합니다."""
-     # 교회 조회
-     db_church = db.query(Church).filter(
-         Church.id == church_id,
-         Church.is_deleted == 'F'
-     ).first()
- 
-     if db_church is None:
-         raise HTTPException(status_code=404, detail="교회를 찾을 수 없습니다")
- 
-     # 권한 확인
-     is_admin = db.query(ChurchAdmin).filter(
-         ChurchAdmin.church_id == church_id,
-         ChurchAdmin.user_id == current_user.id,
-         ChurchAdmin.is_deleted == 'F'
-     ).first()
- 
-     if not is_admin:
-         raise HTTPException(status_code=403, detail="접근 권한이 없습니다")
- 
-     # 주보 목록 조회
-     bulletins = db.query(Bulletin).filter(
-         Bulletin.church_id == church_id,
-         Bulletin.is_deleted == 'F'
-     ).order_by(Bulletin.date.desc()).offset(skip).limit(limit).all()
- 
-     return bulletins
+     return BulletinService.get_bulletins_by_church(db, church_id, current_user.id, skip, limit)
  
  
  ):
      """새 주보를 생성합니다."""
-     # 교회 조회
-     db_church = db.query(Church).filter(
-         Church.id == church_id,
-         Church.is_deleted == 'F'
-     ).first()
- 
-     if db_church is None:
-         raise HTTPException(status_code=404, detail="교회를 찾을 수 없습니다")
- 
-     # 권한 확인
-     is_admin = db.query(ChurchAdmin).filter(
-         ChurchAdmin.church_id == church_id,
-         ChurchAdmin.user_id == current_user.id,
-         ChurchAdmin.is_deleted == 'F'
-     ).first()
- 
-     if not is_admin:
-         raise HTTPException(status_code=403, detail="접근 권한이 없습니다")
- 
-     # 템플릿 확인
-     template = db.query(BulletinTemplate).filter(
-         BulletinTemplate.id == bulletin.template_id,
-         BulletinTemplate.church_id == church_id,
-         BulletinTemplate.is_deleted == 'F'
-     ).first()
- 
-     if template is None:
-         raise HTTPException(status_code=404, detail="템플릿을 찾을 수 없습니다")
- 
-     # 주보 생성
-     new_bulletin = Bulletin(
-         church_id=church_id,
-         template_id=bulletin.template_id,
-         date=bulletin.date,
-         content=bulletin.content
-     )
-     db.add(new_bulletin)
-     db.commit()
-     db.refresh(new_bulletin)
- 
-     return new_bulletin
+     return BulletinService.create(db, church_id, current_user, bulletin)
  
  
  ):
      """특정 주보 정보를 반환합니다."""
-     # 교회 조회
-     db_church = db.query(Church).filter(
-         Church.id == church_id,
-         Church.is_deleted == 'F'
-     ).first()
- 
-     if db_church is None:
-         raise HTTPException(status_code=404, detail="교회를 찾을 수 없습니다")
- 
-     # 권한 확인
-     is_admin = db.query(ChurchAdmin).filter(
-         ChurchAdmin.church_id == church_id,
-         ChurchAdmin.user_id == current_user.id,
-         ChurchAdmin.is_deleted == 'F'
-     ).first()
- 
-     if not is_admin:
-         raise HTTPException(status_code=403, detail="접근 권한이 없습니다")
- 
-     # 주보 조회
-     bulletin = db.query(Bulletin).filter(
-         Bulletin.id == bulletin_id,
-         Bulletin.church_id == church_id,
-         Bulletin.is_deleted == 'F'
-     ).first()
- 
-     if bulletin is None:
-         raise HTTPException(status_code=404, detail="주보를 찾을 수 없습니다")
- 
-     return bulletin
+     return BulletinService.get_bulletin(db, church_id, bulletin_id, current_user.id)
  
  
  ):
      """주보 정보를 수정합니다."""
-     # 교회 조회
-     db_church = db.query(Church).filter(
-         Church.id == church_id,
-         Church.is_deleted == 'F'
-     ).first()
- 
-     if db_church is None:
-         raise HTTPException(status_code=404, detail="교회를 찾을 수 없습니다")
- 
-     # 권한 확인
-     is_admin = db.query(ChurchAdmin).filter(
-         ChurchAdmin.church_id == church_id,
-         ChurchAdmin.user_id == current_user.id,
-         ChurchAdmin.is_deleted == 'F'
-     ).first()
- 
-     if not is_admin:
-         raise HTTPException(status_code=403, detail="접근 권한이 없습니다")
- 
-     # 주보 조회
-     bulletin = db.query(Bulletin).filter(
-         Bulletin.id == bulletin_id,
-         Bulletin.church_id == church_id,
-         Bulletin.is_deleted == 'F'
-     ).first()
- 
-     if bulletin is None:
-         raise HTTPException(status_code=404, detail="주보를 찾을 수 없습니다")
- 
-     # 템플릿 변경 시 확인
-     if bulletin_update.template_id is not None:
-         template = db.query(BulletinTemplate).filter(
-             BulletinTemplate.id == bulletin_update.template_id,
-             BulletinTemplate.church_id == church_id,
-             BulletinTemplate.is_deleted == 'F'
-         ).first()
- 
-         if template is None:
-             raise HTTPException(status_code=404, detail="템플릿을 찾을 수 없습니다")
- 
-     # 주보 정보 업데이트
      update_data = bulletin_update.dict(exclude_unset=True)
-     for key, value in update_data.items():
-         setattr(bulletin, key, value)
- 
-     db.commit()
-     db.refresh(bulletin)
-     return bulletin
+     return BulletinService.update_bulletin(db, church_id, bulletin_id, current_user.id, update_data)
  
  
  ):
      """주보를 삭제합니다."""
-     # 교회 조회
-     db_church = db.query(Church).filter(
-         Church.id == church_id,
-         Church.is_deleted == 'F'
-     ).first()
- 
-     if db_church is None:
-         raise HTTPException(status_code=404, detail="교회를 찾을 수 없습니다")
- 
-     # 권한 확인
-     is_admin = db.query(ChurchAdmin).filter(
-         ChurchAdmin.church_id == church_id,
-         ChurchAdmin.user_id == current_user.id,
-         ChurchAdmin.is_deleted == 'F'
-     ).first()
- 
-     if not is_admin:
-         raise HTTPException(status_code=403, detail="접근 권한이 없습니다")
- 
-     # 주보 조회
-     bulletin = db.query(Bulletin).filter(
-         Bulletin.id == bulletin_id,
-         Bulletin.church_id == church_id,
-         Bulletin.is_deleted == 'F'
-     ).first()
- 
-     if bulletin is None:
-         raise HTTPException(status_code=404, detail="주보를 찾을 수 없습니다")
- 
-     # 주보 삭제 처리 (소프트 삭제)
-     bulletin.is_deleted = True
-     bulletin.deleted_at = datetime.now()
-     db.commit()
- 
-     return {"detail": "주보가 삭제되었습니다"}
+     return BulletinService.delete_bulletin(db, church_id, bulletin_id, current_user.id)
  
  
```

---

_****_

모든 작업이 완료되었습니다! 이제 주보 라우터에서 반복되는 교회 정보 조회와 권한 확인 로직이 모두 서비스 계층으로 이동되었습니다. 다음은 변경된 내용을 요약해 드리겠습니다:

## 주요 변경 사항

### 1. `ChurchService` 클래스에 추가된 메서드

```python
@staticmethod
def check_church_access(
    db: Session,
    church_id: int,
    user_id: int
) -> Church:
    """교회 접근 권한을 확인하고 교회 정보를 반환합니다."""
    # 교회 조회
    db_church = db.query(Church).filter(
        Church.id == church_id,
        Church.is_deleted == 'F'
    ).first()

    if db_church is None:
        raise HTTPException(status_code=404, detail="교회를 찾을 수 없습니다")

    # 권한 확인
    is_admin = db.query(ChurchAdmin).filter(
        ChurchAdmin.church_id == church_id,
        ChurchAdmin.user_id == user_id,
        ChurchAdmin.is_deleted == 'F'
    ).first()

    if not is_admin:
        raise HTTPException(status_code=403, detail="접근 권한이 없습니다")

    return db_church
```

### 2. `BulletinService` 클래스에 추가된 메서드들

1. `get_bulletins_by_church`: 교회별 주보 목록 조회
2. `get_bulletin`: 특정 주보 정보 조회
3. `update_bulletin`: 주보 정보 수정
4. `delete_bulletin`: 주보 삭제
5. `check_bulletin_access` 메서드 개선: `ChurchService.check_church_access` 활용

### 3. 라우터 코드 간소화

모든 라우터 엔드포인트가 서비스 계층의 메서드를 호출하는 한 줄의 코드로 간소화되었습니다.

## 개선 효과

1. **코드 중복 제거**: 각 엔드포인트에서 반복되던 교회 조회 및 권한 확인 로직이 제거되어 코드 중복이 줄었습니다.
2. **관심사 분리**: 라우터는 요청 처리와 응답 반환에만 집중하고, 비즈니스 로직은 서비스 계층에서 처리됩니다.
3. **유지보수성 향상**: 교회 접근 권한 확인 로직이 변경되면 한 곳(`ChurchService.check_church_access`)만 수정하면 됩니다.
4. **일관성 유지**: 모든 엔드포인트에서 동일한 방식으로 교회 접근 권한을 확인하게 되어 일관성이 유지됩니다.
5. **코드 가독성 향상**: 라우터 코드가 간결해져 전체 코드의 가독성이 향상되었습니다.

이제 모든 엔드포인트에서 동일한 패턴으로 교회 접근 권한을 확인하고, 엔드포인트별 특수 로직만 처리하게 되어 코드의 품질이 크게 향상되었습니다.

---

_**User**_

서비스에서 Exception을 발생하는데 route에서 try catch를 안해도 되는거야?

---

_**Assistant**_

FastAPI에서 서비스 계층에서 발생하는 예외(Exception) 처리에 대한 질문에 답변드리겠습니다.

네, FastAPI는 기본적으로 라우터에서 명시적인 try-catch를 하지 않아도 서비스 계층에서 발생한 예외를 자동으로 처리합니다. 이것은 FastAPI의 중요한 기능 중 하나입니다.

## FastAPI의 예외 처리 특징

1. **자동 예외 변환**: 
   - FastAPI는 `HTTPException`을 자동으로 적절한 HTTP 응답으로 변환합니다.
   - 예를 들어, 서비스에서 `HTTPException(status_code=404, detail="주보를 찾을 수 없습니다")`를 발생시키면, FastAPI는 자동으로 404 상태 코드와 함께 JSON 응답 `{"detail": "주보를 찾을 수 없습니다"}`을 클라이언트에 반환합니다.

2. **미들웨어 처리**:
   - FastAPI는 내부적으로 예외 처리 미들웨어를 사용하여 라우트 핸들러나 의존성에서 발생하는 모든 예외를 처리합니다.
   - 이 미들웨어는 예외를 캐치하고 적절한 HTTP 응답으로 변환합니다.

3. **일관된 응답 형식**:
   - HTTPException은 항상 일관된 형식의 JSON 응답을 생성합니다.
   - 이는 클라이언트가 오류 응답을 쉽게 처리할 수 있도록 합니다.

## 현재 코드의 예외 처리 패턴

현재 구현된 코드에서는 다음과 같은 패턴으로 예외 처리가 이루어지고 있습니다:

1. **서비스 계층**:
   ```python
   # 예: ChurchService.check_church_access 메서드
   if db_church is None:
       raise HTTPException(status_code=404, detail="교회를 찾을 수 없습니다")
   
   if not is_admin:
       raise HTTPException(status_code=403, detail="접근 권한이 없습니다")
   ```

2. **라우터 계층**:
   ```python
   # 라우터에서는 별도의 try-catch 없이 직접 서비스 호출
   return BulletinService.get_bulletin(db, church_id, bulletin_id, current_user.id)
   ```

이 패턴은 다음과 같은 이유로 효과적입니다:

- **코드 간결성**: 라우터에서 불필요한 try-catch 블록을 피할 수 있습니다.
- **책임 분리**: 비즈니스 로직과 오류 처리가 서비스 계층에 집중됩니다.
- **일관성**: 모든 오류 처리가 한 곳에서 이루어집니다.

## 알아두면 좋은 추가 내용

1. **전역 예외 핸들러 등록 가능**:
   - 특정 예외에 대해 전역 핸들러를 등록할 수도 있습니다.
   ```python
   @app.exception_handler(CustomException)
   async def custom_exception_handler(request, exc):
       return JSONResponse(
           status_code=418,
           content={"detail": str(exc)},
       )
   ```

2. **사용자 정의 예외**:
   - 필요한 경우 HTTPException을 상속하여 사용자 정의 예외를 만들 수 있습니다.
   ```python
   class NotFoundError(HTTPException):
       def __init__(self, detail: str):
           super().__init__(status_code=404, detail=detail)
   ```

3. **일반 예외의 처리**:
   - HTTPException이 아닌 일반 Python 예외(예: ValueError, TypeError 등)도 FastAPI에 의해 500 Internal Server Error로 변환됩니다.
   - 개발 환경에서는 상세한 오류 정보가 표시되지만, 프로덕션 환경에서는 보안을 위해 생략됩니다.

## 현재 구현에 대한 평가

현재 구현은 FastAPI의 장점을 잘 활용하고 있습니다:

1. **명확한 오류 메시지**: 각 예외에 명확한 메시지가 포함되어 있습니다.
2. **적절한 상태 코드**: 적절한 HTTP 상태 코드를 사용하고 있습니다.
3. **코드 중복 제거**: 공통 오류 처리 로직이 중복되지 않습니다.

## 결론

라우터에서 별도의 try-catch 블록 없이 서비스 계층에서 `HTTPException`을 발생시키는 현재 방식은 FastAPI의 설계 철학과 잘 맞는 좋은 방식입니다. 라우터는 요청 처리와 응답 반환에 집중하고, 비즈니스 로직과 예외 처리는 서비스 계층에서 담당하는 현재의 코드 구조는 유지보수성과 가독성 측면에서 바람직합니다.

프로젝트가 복잡해지면 전역 예외 핸들러나 사용자 정의 예외 클래스를 고려해볼 수 있지만, 현재의 구현도 충분히 효과적입니다.

---

_**User**_

templates 라우터에서도 위에서 묶인 코드를 활용할 수 있을거 같아. 여기도 수정해줘.

---

_**Assistant**_

`templates` 라우터도 동일한 방식으로 리팩토링하여 코드 중복을 제거하고 서비스 계층을 활용하도록 수정하겠습니다. 먼저 현재 템플릿 라우터 코드를 살펴보겠습니다.

---

_****_

Read file: undefined

---

_****_

이제 `templates` 라우터에서도 중복 코드를 제거하고 서비스 계층을 활용하도록 수정하겠습니다. 먼저 `TemplateService` 클래스를 생성해야 합니다.

---

_****_

```diff
- 
+ from sqlalchemy.orm import Session
+ from datetime import datetime
+ from typing import List, Optional, Dict, Any
+ 
+ from app.models import BulletinTemplate
+ from app.schemas import BulletinTemplateCreate, BulletinTemplateUpdate
+ from fastapi import HTTPException
+ from app.services.church import ChurchService
+ 
+ 
+ class TemplateService:
+     """템플릿 관련 서비스 클래스"""
+ 
+     @staticmethod
+     def get_templates_by_church(
+         db: Session,
+         church_id: int,
+         user_id: int,
+         skip: int = 0,
+         limit: int = 100
+     ) -> List[BulletinTemplate]:
+         """교회별 템플릿 목록 조회"""
+         # 교회 접근 권한 확인
+         ChurchService.check_church_access(db, church_id, user_id)
+ 
+         # 템플릿 목록 조회
+         templates = db.query(BulletinTemplate).filter(
+             BulletinTemplate.church_id == church_id,
+             BulletinTemplate.is_deleted == 'F'
+         ).offset(skip).limit(limit).all()
+ 
+         return templates
+ 
+     @staticmethod
+     def create_template(
+         db: Session,
+         church_id: int,
+         user_id: int,
+         template_data: BulletinTemplateCreate
+     ) -> BulletinTemplate:
+         """새로운 템플릿 생성"""
+         # 교회 접근 권한 확인
+         ChurchService.check_church_access(db, church_id, user_id)
+ 
+         # 템플릿 생성
+         new_template = BulletinTemplate(
+             church_id=church_id,
+             name=template_data.name,
+             template_data=template_data.template_data
+         )
+         db.add(new_template)
+         db.commit()
+         db.refresh(new_template)
+ 
+         return new_template
+ 
+     @staticmethod
+     def check_template_access(
+         db: Session,
+         church_id: int,
+         template_id: int,
+         user_id: int
+     ) -> BulletinTemplate:
+         """템플릿 접근 권한 확인 및 템플릿 조회"""
+         # 교회 접근 권한 확인
+         ChurchService.check_church_access(db, church_id, user_id)
+ 
+         # 템플릿 조회
+         template = db.query(BulletinTemplate).filter(
+             BulletinTemplate.id == template_id,
+             BulletinTemplate.church_id == church_id,
+             BulletinTemplate.is_deleted == 'F'
+         ).first()
+ 
+         if template is None:
+             raise HTTPException(status_code=404, detail="템플릿을 찾을 수 없습니다")
+ 
+         return template
+ 
+     @staticmethod
+     def get_template(
+         db: Session,
+         church_id: int,
+         template_id: int,
+         user_id: int
+     ) -> BulletinTemplate:
+         """특정 템플릿 정보 조회"""
+         return TemplateService.check_template_access(db, church_id, template_id, user_id)
+ 
+     @staticmethod
+     def update_template(
+         db: Session,
+         church_id: int,
+         template_id: int,
+         user_id: int,
+         template_update_data: Dict[str, Any]
+     ) -> BulletinTemplate:
+         """템플릿 정보 수정"""
+         # 템플릿 접근 권한 확인 및 템플릿 조회
+         template = TemplateService.check_template_access(db, church_id, template_id, user_id)
+ 
+         # 템플릿 정보 업데이트
+         for key, value in template_update_data.items():
+             setattr(template, key, value)
+ 
+         db.commit()
+         db.refresh(template)
+         return template
+ 
+     @staticmethod
+     def delete_template(
+         db: Session,
+         church_id: int,
+         template_id: int,
+         user_id: int
+     ) -> Dict[str, str]:
+         """템플릿 삭제"""
+         # 템플릿 접근 권한 확인 및 템플릿 조회
+         template = TemplateService.check_template_access(db, church_id, template_id, user_id)
+ 
+         # 템플릿 삭제 처리 (소프트 삭제)
+         template.is_deleted = 'T'
+         template.deleted_at = datetime.now()
+         db.commit()
+ 
+         return {"detail": "템플릿이 삭제되었습니다"}
+ 
+     @staticmethod
+     def copy_template(
+         db: Session,
+         church_id: int,
+         template_id: int,
+         user_id: int
+     ) -> BulletinTemplate:
+         """템플릿 복사"""
+         # 원본 템플릿 접근 권한 확인 및 조회
+         original_template = TemplateService.check_template_access(db, church_id, template_id, user_id)
+ 
+         # 복사된 템플릿 생성
+         new_template = BulletinTemplate(
+             church_id=church_id,
+             name=f"{original_template.name} (복사본)",
+             template_data=original_template.template_data
+         )
+         db.add(new_template)
+         db.commit()
+         db.refresh(new_template)
+ 
+         return new_template
```

---

_****_

```diff
  from sqlalchemy.orm import Session
  from datetime import datetime
- from typing import List, Optional, Dict, Any
+ from typing import List, Dict, Any
  
  from app.models import BulletinTemplate
- from app.schemas import BulletinTemplateCreate, BulletinTemplateUpdate
+ from app.schemas import BulletinTemplateCreate
  from fastapi import HTTPException
  from app.services.church import ChurchService
```

---

_****_

```diff
  from app.services.bulletin import BulletinService
  from app.services.church import ChurchService
+ from app.services.template import TemplateService
  
- __all__ = ["AuthService", "UserService", "BulletinService", "ChurchService"]
+ __all__ = ["AuthService", "UserService", "BulletinService", "ChurchService", "TemplateService"]
  
```

---

_****_

이제 `templates.py` 라우터를 수정하여 새로 만든 서비스 계층을 활용하도록 하겠습니다:

---

_****_

```diff
- from fastapi import APIRouter, Depends, HTTPException
+ from fastapi import APIRouter, Depends
  from sqlalchemy.orm import Session
  from typing import List
- from datetime import datetime
  
  from app import schemas
- from app.models import Church, ChurchAdmin, BulletinTemplate
  from app.db.session import get_db
  from app.models.user import User
  from app.services.auth import AuthService
+ from app.services.template import TemplateService
+ 
  router = APIRouter()
  
  ):
      """특정 교회의 템플릿 목록을 반환합니다."""
-     # 교회 조회
-     db_church = db.query(Church).filter(
-         Church.id == church_id,
-         Church.is_deleted == 'F'
-     ).first()
- 
-     if db_church is None:
-         raise HTTPException(status_code=404, detail="교회를 찾을 수 없습니다")
- 
-     # 권한 확인
-     is_admin = db.query(ChurchAdmin).filter(
-         ChurchAdmin.church_id == church_id,
-         ChurchAdmin.user_id == current_user.id,
-         ChurchAdmin.is_deleted == 'F'
-     ).first()
- 
-     if not is_admin:
-         raise HTTPException(status_code=403, detail="접근 권한이 없습니다")
- 
-     # 템플릿 목록 조회
-     templates = db.query(BulletinTemplate).filter(
-         BulletinTemplate.church_id == church_id,
-         BulletinTemplate.is_deleted == 'F'
-     ).offset(skip).limit(limit).all()
- 
-     return templates
+     return TemplateService.get_templates_by_church(db, church_id, current_user.id, skip, limit)
  
  
  ):
      """새 템플릿을 생성합니다."""
-     # 교회 조회
-     db_church = db.query(Church).filter(
-         Church.id == church_id,
-         Church.is_deleted == 'F'
-     ).first()
- 
-     if db_church is None:
-         raise HTTPException(status_code=404, detail="교회를 찾을 수 없습니다")
- 
-     # 권한 확인
-     is_admin = db.query(ChurchAdmin).filter(
-         ChurchAdmin.church_id == church_id,
-         ChurchAdmin.user_id == current_user.id,
-         ChurchAdmin.is_deleted == 'F'
-     ).first()
- 
-     if not is_admin:
-         raise HTTPException(status_code=403, detail="접근 권한이 없습니다")
- 
-     # 템플릿 생성
-     new_template = BulletinTemplate(
-         church_id=church_id,
-         name=template.name,
-         template_data=template.template_data
-     )
-     db.add(new_template)
-     db.commit()
-     db.refresh(new_template)
- 
-     return new_template
+     return TemplateService.create_template(db, church_id, current_user.id, template)
  
  
  ):
      """특정 템플릿 정보를 반환합니다."""
-     # 교회 조회
-     db_church = db.query(Church).filter(
-         Church.id == church_id,
-         Church.is_deleted == 'F'
-     ).first()
- 
-     if db_church is None:
-         raise HTTPException(status_code=404, detail="교회를 찾을 수 없습니다")
- 
-     # 권한 확인
-     is_admin = db.query(ChurchAdmin).filter(
-         ChurchAdmin.church_id == church_id,
-         ChurchAdmin.user_id == current_user.id,
-         ChurchAdmin.is_deleted == 'F'
-     ).first()
- 
-     if not is_admin:
-         raise HTTPException(status_code=403, detail="접근 권한이 없습니다")
- 
-     # 템플릿 조회
-     template = db.query(BulletinTemplate).filter(
-         BulletinTemplate.id == template_id,
-         BulletinTemplate.church_id == church_id,
-         BulletinTemplate.is_deleted == 'F'
-     ).first()
- 
-     if template is None:
-         raise HTTPException(status_code=404, detail="템플릿을 찾을 수 없습니다")
- 
-     return template
+     return TemplateService.get_template(db, church_id, template_id, current_user.id)
  
  
  ):
      """템플릿 정보를 수정합니다."""
-     # 교회 조회
-     db_church = db.query(Church).filter(
-         Church.id == church_id,
-         Church.is_deleted == 'F'
-     ).first()
- 
-     if db_church is None:
-         raise HTTPException(status_code=404, detail="교회를 찾을 수 없습니다")
- 
-     # 권한 확인
-     is_admin = db.query(ChurchAdmin).filter(
-         ChurchAdmin.church_id == church_id,
-         ChurchAdmin.user_id == current_user.id,
-         ChurchAdmin.is_deleted == 'F'
-     ).first()
- 
-     if not is_admin:
-         raise HTTPException(status_code=403, detail="접근 권한이 없습니다")
- 
-     # 템플릿 조회
-     template = db.query(BulletinTemplate).filter(
-         BulletinTemplate.id == template_id,
-         BulletinTemplate.church_id == church_id,
-         BulletinTemplate.is_deleted == 'F'
-     ).first()
- 
-     if template is None:
-         raise HTTPException(status_code=404, detail="템플릿을 찾을 수 없습니다")
- 
-     # 템플릿 정보 업데이트
      update_data = template_update.dict(exclude_unset=True)
-     for key, value in update_data.items():
-         setattr(template, key, value)
- 
-     db.commit()
-     db.refresh(template)
-     return template
+     return TemplateService.update_template(db, church_id, template_id, current_user.id, update_data)
  
  
  ):
      """템플릿을 삭제합니다."""
-     # 교회 조회
-     db_church = db.query(Church).filter(
-         Church.id == church_id,
-         Church.is_deleted == 'F'
-     ).first()
- 
-     if db_church is None:
-         raise HTTPException(status_code=404, detail="교회를 찾을 수 없습니다")
- 
-     # 권한 확인
-     is_admin = db.query(ChurchAdmin).filter(
-         ChurchAdmin.church_id == church_id,
-         ChurchAdmin.user_id == current_user.id,
-         ChurchAdmin.is_deleted == 'F'
-     ).first()
- 
-     if not is_admin:
-         raise HTTPException(status_code=403, detail="접근 권한이 없습니다")
- 
-     # 템플릿 조회
-     template = db.query(BulletinTemplate).filter(
-         BulletinTemplate.id == template_id,
-         BulletinTemplate.church_id == church_id,
-         BulletinTemplate.is_deleted == 'F'
-     ).first()
- 
-     if template is None:
-         raise HTTPException(status_code=404, detail="템플릿을 찾을 수 없습니다")
- 
-     # 템플릿 삭제 처리 (소프트 삭제)
-     template.is_deleted = True
-     template.deleted_at = datetime.now()
-     db.commit()
- 
-     return {"detail": "템플릿이 삭제되었습니다"}
+     return TemplateService.delete_template(db, church_id, template_id, current_user.id)
  
  
  ):
      """기존 템플릿을 복사하여 새 템플릿을 생성합니다."""
-     # 교회 조회
-     db_church = db.query(Church).filter(
-         Church.id == church_id,
-         Church.is_deleted == 'F'
-     ).first()
- 
-     if db_church is None:
-         raise HTTPException(status_code=404, detail="교회를 찾을 수 없습니다")
- 
-     # 권한 확인
-     is_admin = db.query(ChurchAdmin).filter(
-         ChurchAdmin.church_id == church_id,
-         ChurchAdmin.user_id == current_user.id,
-         ChurchAdmin.is_deleted == 'F'
-     ).first()
- 
-     if not is_admin:
-         raise HTTPException(status_code=403, detail="접근 권한이 없습니다")
- 
-     # 원본 템플릿 조회
-     original_template = db.query(BulletinTemplate).filter(
-         BulletinTemplate.id == template_id,
-         BulletinTemplate.church_id == church_id,
-         BulletinTemplate.is_deleted == 'F'
-     ).first()
- 
-     if original_template is None:
-         raise HTTPException(status_code=404, detail="템플릿을 찾을 수 없습니다")
- 
-     # 복사본 생성
-     new_template = BulletinTemplate(
-         church_id=church_id,
-         name=f"{original_template.name} (복사본)",
-         template_data=original_template.template_data
-     )
-     db.add(new_template)
-     db.commit()
-     db.refresh(new_template)
- 
-     return new_template
+     return TemplateService.copy_template(db, church_id, template_id, current_user.id)
  
```

---

_****_

템플릿 라우터의 리팩토링이

---



---

